import random
from tools import helpers, misc
import argparse
import tools.progressbar1 as progressbar1
from tools.valley_free_tools import VFT as vft
import logging
import igraph

misc.logger_setup()
logger = logging.getLogger('compnet.random_ba_walking')
logging.getLogger('compnet').setLevel(logging.INFO)


def main():
    desc = 'Toolset for random  walks in Barabasi-Albert graph'
    formatter = argparse.ArgumentDefaultsHelpFormatter
    parser = argparse.ArgumentParser(
        description=desc, formatter_class=formatter)

    parser.add_argument('--progressbar', action='store_true')
    parser.add_argument('--verbose', '-v', action='count', default=0)

    subparsers = parser.add_subparsers(help=('Sub commands to switch '
                                             'between different functions'))

    ba_help = ('Generate Barabasi-Albert graph, based on vertex '
               'and node count of a specified graph')
    parser_bagen = subparsers.add_parser('ba-generator', help=ba_help)
    parser_bagen.add_argument('input_graph', metavar='input-graph')
    parser_bagen.add_argument('ba_output', metavar='ba-output')
    parser_bagen.add_argument(
        '--use-degree-sequence',
        '-ds',
        dest='use_degree_seq',
        action='store_true')
    parser_bagen.set_defaults(dispatch=ba_gen)

    sh_help = ('Generate random pontpairs in a given graph and '
               'calculate its shortest path length')
    parser_shgen = subparsers.add_parser('sh-path-generator', help=sh_help)
    parser_shgen.add_argument('ba_graph', metavar='ba-graph')
    parser_shgen.add_argument('sh_path_output', metavar='sh-path-output')
    parser_shgen.add_argument('--route-count', default=1000)
    parser_shgen.set_defaults(dispatch=sh_gen)

    ba_help = 'Run random walks on given graph using given node pairs'
    parser_bacalc = subparsers.add_parser('ba-calculator', help=ba_help)
    parser_bacalc.add_argument('ba_graph', metavar='ba-graph')
    parser_bacalc.add_argument('point_pairs', metavar='point-pairs')
    parser_bacalc.add_argument('out')
    parser_bacalc.add_argument('--min-stretch', default=0, type=int)
    parser_bacalc.add_argument('--max-stretch', default=4, type=int)
    # for paralelization
    parser_bacalc.add_argument(
        '--lower-bound', '-lb', type=int, default=0, dest='lb')
    parser_bacalc.add_argument(
        '--upper-bound', '-ub', type=int, default=-1, dest='ub')
    parser_bacalc.set_defaults(dispatch=ba_calc)

    merge_help = 'Merge results generated by running multiple paralell ba-calculators'
    parser_merge = subparsers.add_parser('ba-merge', help=merge_help)
    parser_merge.add_argument(
        'out', metavar='output-file', type=argparse.FileType('w'))
    parser_merge.add_argument('res', metavar='result-pieces', nargs='*')
    parser_merge.set_defaults(dispatch=ba_merge)

    arguments = parser.parse_args()

    arguments.verbose = min(len(helpers.LEVELS), arguments.verbose)
    logging.getLogger('compnet').setLevel(helpers.LEVELS[arguments.verbose])

    arguments.dispatch(arguments)


def _degree_graph(g):
    out_degrees = g.degree(mode=igraph.OUT)
    args = {"out": out_degrees, "method": "no_multiple"}
    if g.is_directed():
        in_degrees = g.degree(mode=igraph.IN)
        args['in'] = in_degrees

    logger.info('Generate [b]DegreeSeq[/] graph')
    # logger.debug('Params: %s' % args)
    ds_graph = igraph.Graph.Degree_Sequence(**args)

    return ds_graph


def _ba_graph(g):
    average_degree = sum(g.degree(mode=igraph.OUT)) / float(g.vcount())
    N = g.vcount()
    M = int(average_degree / 2.0)
    logger.info('Generate [b]BA[/] graph. N: [g]%d[/], M: [g]%d[/]' % (N, M))
    ba_graph = igraph.Graph.Barabasi(N, M)

    return ba_graph


def ba_gen(arguments):
    g = helpers.load_network(arguments.input_graph)

    if arguments.use_degree_seq:
        method = 'Degree Seq.'
        generated_graph = _degree_graph(g)
    else:
        method = 'Barabasi-Albert'
        generated_graph = _ba_graph(g)

    logger.info('Used method: [b]%s[/]' % method)

    logger.debug('Graph created. Fill up closeness values')
    N = generated_graph.vcount()
    progress = progressbar1.DummyProgressBar(end=10, width=15)

    if arguments.progressbar:
        progress = progressbar1.AnimatedProgressBar(end=N, width=15)

    for vs in generated_graph.vs:
        progress += 1
        progress.show_progress()
        vs['name'] = 'BA%s' % vs.index
        vs['closeness'] = generated_graph.closeness(vs, mode=igraph.OUT)
    logger.info('Save to %s' % arguments.ba_output)
    generated_graph.save(arguments.ba_output)


def sh_gen(arguments):
    ba_graph = helpers.load_network(arguments.ba_graph)
    trace_count = int(arguments.route_count)
    node_ids = range(ba_graph.vcount())
    logger.info('Trace count: %d' % trace_count)

    random_pairs = [random.sample(node_ids, 2) for x in xrange(trace_count)]
    random_pairs = [(ba_graph.vs[x[0]]['name'], ba_graph.vs[x[1]]['name'])
                    for x in random_pairs]
    logger.info('Random pair count: %d' % len(random_pairs))

    shls = []
    results = []
    for s_name, t_name in random_pairs:
        shl = ba_graph.shortest_paths(s_name, t_name)[0][0] + 1
        while shl == float('inf'):
            s, t = random.sample(node_ids, 2)
            s_name = ba_graph.vs[s]['name']
            t_name = ba_graph.vs[t]['name']
            shl = ba_graph.shortest_paths(s_name, t_name)[0][0] + 1
        logger.debug('From %s to %s SH: %d' % (s_name, t_name, shl))
        shls.append(shl)
        results.append([(s_name, t_name), shl])

    # result = zip(random_pairs, shls)
    helpers.save_to_json(arguments.sh_path_output, results)


def ba_calc(arguments):
    ba_graph = helpers.load_network(arguments.ba_graph)
    sh_paths = helpers.load_from_json(arguments.point_pairs)
    out = arguments.out

    min_stretch = arguments.min_stretch
    max_stretch = arguments.max_stretch

    max_c = len(sh_paths)
    arguments.lb = arguments.lb if 0 <= arguments.lb <= max_c else 0
    arguments.ub = arguments.ub if 0 <= arguments.ub <= max_c else max_c

    arguments.lb, arguments.ub = (min(arguments.lb, arguments.ub),
                                  max(arguments.lb, arguments.ub))

    sh_paths = sh_paths[arguments.lb:arguments.ub]
    vf_g_closeness = vft.convert_to_vf(ba_graph, vfmode=vft.CLOSENESS)

    results = [[] for x in xrange(min_stretch, max_stretch + 1)]

    for stretch in xrange(min_stretch, max_stretch + 1):
        logger.info('Calculate results with stretch %d' % stretch)
        result = ba_generator(ba_graph, sh_paths, stretch, vf_g_closeness,
                              arguments.progressbar)
        results[stretch - min_stretch] = result

    helpers.save_to_json(out, results)


def ba_generator(ba_graph, sh_paths, stretch, vf_g, progressbar=False):
    vf_count = 0
    trace_count = 0
    lp_count = 0
    progress = progressbar1.DummyProgressBar(end=10, width=15)

    if progressbar:
        progress = progressbar1.AnimatedProgressBar(
            end=len(sh_paths), width=15)
    for (s, t), shl in sh_paths:
        progress += 1
        progress.show_progress()
        logger.debug('SH from %s to %s is %d' % (s, t, shl))
        random_route = helpers.random_route_walk(ba_graph, s, t, shl + stretch)
        logger.debug('Random route: %s' % random_route)
        real_stretch = len(random_route) - shl

        if real_stretch != stretch:
            continue

        trace_count += 1

        is_vf = vft.is_valley_free(
            ba_graph, random_route, vfmode=vft.CLOSENESS)
        logger.debug('Trace edge dir: %s' % vft.trace_to_string(
            ba_graph, random_route, vfmode=vft.CLOSENESS))
        logger.debug('Is VF: %s' % is_vf)
        if is_vf:
            is_lp = vft.is_local_preferenced(
                ba_graph,
                random_route,
                first_edge=True,
                vfmode=vft.CLOSENESS,
                vf_g=vf_g)
        else:
            is_lp = 0
        logger.debug('Is LP: %s' % is_lp)

        vf_count += int(is_vf)
        lp_count += int(is_lp)

    logger.info('Stretch %d' % stretch)
    logger.info('Trace count: %d' % trace_count)
    logger.info('VF count: %d' % vf_count)
    logger.info('LP count: %d' % lp_count)

    return (stretch, trace_count, vf_count, lp_count)


def ba_merge(arguments):
    STRETCH, TRACE_COUNT, VF_COUNT, LP_COUNT = range(4)

    out_file = arguments.out
    results = dict()

    for piece in arguments.res:
        result_piece = helpers.load_from_json(piece)
        for res in result_piece:
            stretch = res[0]
            try:
                container = results[stretch]
            except KeyError:
                container = [stretch, 0, 0, 0]
                results[stretch] = container

            for idx in [TRACE_COUNT, VF_COUNT, LP_COUNT]:
                container[idx] += res[idx]

    results_list = []
    for idx in sorted(results.iterkeys()):
        results_list.append(results[idx])

    helpers.save_to_json_file(out_file, results_list)


if __name__ == '__main__':
    main()
